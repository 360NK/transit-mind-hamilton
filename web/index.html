<!DOCTYPE html>
<html>
  <head>
    <title>TransitMind: Hamilton</title>
    <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #111;
        color: white;
        font-family: monospace;
      }
      #container {
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border: 1px solid #333;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <h2>TRANSITMIND</h2>
      <div id="status">Connecting to Neural Net...</div>
    </div>
    <div id="container"></div>
    <script>
      // 1. CONFIGURATION
      const MAPBOX_TOKEN =
        "pk.eyJ1IjoiMzYwbmsiLCJhIjoiY21qbjVpY2JkMzNkNTNncHV2Mzc2bmRqYSJ9.PpeBij1HTS3VOPn3UHuAVA"

      const { DeckGL, GeoJsonLayer } = deck

      // 2. INITIALIZE THE MAP
      const deckgl = new DeckGL({
        container: "container",
        mapStyle: "mapbox://styles/mapbox/dark-v11",
        mapboxApiAccessToken: MAPBOX_TOKEN,
        initialViewState: {
          longitude: -79.866091,
          latitude: 43.256568,
          zoom: 12,
          pitch: 45,
          bearing: 0,
        },
        controller: true,
        layers: [], // Start empty
      })

      // 3. INITIALIZE: Fetch Static Routes ONCE (Heavy Lift)
      async function initializeMap() {
        console.log("Fetching static routes...")
        try {
          // Note: This endpoint must exist in your api.py!
          const routeResp = await fetch("http://127.0.0.1:8000/static/routes")
          const routeData = await routeResp.json()

          // Create the Route Layer (Blue Lines)
          // We save this to 'window' so we can re-use it every 5 seconds without re-fetching
          window.routeLayer = new GeoJsonLayer({
            id: "routes",
            data: routeData,
            stroked: true,
            filled: false,
            getLineColor: [0, 120, 255, 80], // Blue, semi-transparent
            getLineWidth: 20,
            pickable: false,
          })

          // Now that static data is ready, start the live loop
          startLiveMap()
        } catch (e) {
          console.error("Static Route Error (Is API running?):", e)
          document.getElementById("status").innerText =
            "API ERROR - CHECK CONSOLE"
          document.getElementById("status").style.color = "red"
        }
      }

      // 4. RENDER: Fetch Live Dots & Conflicts (Lightweight)
      async function renderLayers() {
        try {
          // Fetch both live endpoints in parallel
          const [busResp, conflictResp] = await Promise.all([
            fetch("http://127.0.0.1:8000/live/buses"),
            fetch("http://127.0.0.1:8000/conflicts"),
          ])

          const busData = await busResp.json()
          const conflictData = await conflictResp.json()

          // UI Update
          if (busData.features) {
            document.getElementById(
              "status"
            ).innerText = `LIVE: Tracking ${busData.features.length} Vehicles`
          }

          // LAYER A: Conflicts (Red Zones)
          const conflictLayer = new GeoJsonLayer({
            id: "conflicts",
            data: conflictData,
            filled: true,
            stroked: true,
            getFillColor: [255, 0, 0, 100], // Red transparent
            getLineColor: [255, 0, 0, 255], // Red solid outline
            getLineWidth: 40,
            pickable: true,
            onClick: (info) => console.log("CONFLICT:", info.object.properties),
          })

          // LAYER B: Live Buses (Dots)
          const busLayer = new GeoJsonLayer({
            id: "buses",
            data: busData,
            pointRadiusMinPixels: 4,
            getPointRadius: 15,
            // Green if moving, Red if stopped
            getFillColor: (d) =>
              d.properties.speed === 0 ? [255, 0, 0] : [0, 255, 100],
            pickable: true,
            // Rotate the arrow based on bearing
            getAngle: (d) => -d.properties.bearing + 90,
            onClick: (info) => console.log("BUS:", info.object.properties),
          })

          // Combine Layers: Routes (Bottom) -> Conflicts -> Buses (Top)
          const layers = [conflictLayer, busLayer]
          if (window.routeLayer) layers.unshift(window.routeLayer)

          deckgl.setProps({ layers: layers })
        } catch (e) {
          console.error("Render Loop Error:", e)
        }
      }

      // 5. THE LOOP (Recursive)
      async function startLiveMap() {
        await renderLayers() // Wait for completion
        setTimeout(startLiveMap, 5000) // Wait 5s, then run again
      }

      // 6. KICKOFF
      initializeMap()
    </script>
  </body>
</html>
